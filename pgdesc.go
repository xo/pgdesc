// Package pgdesc builds SQL introspection queries for PostgreSQL databases.
//
// Mix of generated and manually rewritten code from PostgreSQL's psql codebase.
//
// Written for use by xo and usql.
package pgdesc

// Code generated by gen.go. DO NOT EDIT.

//go:generate go run gen.go

import (
	"fmt"
	"io"
)

// Postgres RELKIND and other related constants.
const (
	COERCION_CODE_ASSIGNMENT  = 'a' // coercion in context of assignment
	COERCION_CODE_EXPLICIT    = 'e' // explicit cast operation
	COERCION_CODE_IMPLICIT    = 'i' // coercion in context of expression
	COERCION_METHOD_BINARY    = 'b' // types are binary-compatible
	COERCION_METHOD_FUNCTION  = 'f' // use a function
	COERCION_METHOD_INOUT     = 'i' // use input/output functions
	DEFACLOBJ_FUNCTION        = 'f' // function
	DEFACLOBJ_NAMESPACE       = 'n' // namespace
	DEFACLOBJ_RELATION        = 'r' // table, view
	DEFACLOBJ_SEQUENCE        = 'S' // sequence
	DEFACLOBJ_TYPE            = 'T' // type
	RELKIND_COMPOSITE_TYPE    = 'c' // composite type
	RELKIND_FOREIGN_TABLE     = 'f' // foreign table
	RELKIND_INDEX             = 'i' // secondary index
	RELKIND_MATVIEW           = 'm' // materialized view
	RELKIND_PARTITIONED_INDEX = 'I' // partitioned index
	RELKIND_PARTITIONED_TABLE = 'p' // partitioned table
	RELKIND_RELATION          = 'r' // ordinary table
	RELKIND_SEQUENCE          = 'S' // sequence object
	RELKIND_TOASTVALUE        = 't' // for out-of-line values
	RELKIND_VIEW              = 'v' // view
	RELPERSISTENCE_PERMANENT  = 'p' // regular table
	RELPERSISTENCE_TEMP       = 't' // temporary table
	RELPERSISTENCE_UNLOGGED   = 'u' // unlogged permanent table
)

// AccessMethods handles \dA.
//
// Generated from describeAccessMethods in psql's describe.c.
//
// \dA
// Takes an optional regexp to select particular access methods
func (d *PgDesc) AccessMethods(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, true, false, false};

	if d.version < 90600 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support access methods.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT amname AS \"%s\",\n"+
			"  CASE amtype"+
			" WHEN 'i' THEN '%s'"+
			" END AS \"%s\"",
		GettextNoop("Name"),
		GettextNoop("Index"),
		GettextNoop("Type"))

	if verbose {
		fmt.Fprintf(w,
			",\n  amhandler AS \"%s\",\n"+
				"  pg_catalog.obj_description(oid, 'pg_am') AS \"%s\"",
			GettextNoop("Handler"),
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_am\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "amname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of access methods");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Aggregates handles \da.
//
// Generated from describeAggregates in psql's describe.c.
//
// \da
// Takes an optional regexp to select particular aggregates
func (d *PgDesc) Aggregates(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  p.proname AS \"%s\",\n"+
			"  pg_catalog.format_type(p.prorettype, NULL) AS \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Result data type"))

	if d.version >= 80400 {
		fmt.Fprintf(w,
			"  CASE WHEN p.pronargs = 0\n"+
				"    THEN CAST('*' AS pg_catalog.text)\n"+
				"    ELSE pg_catalog.pg_get_function_arguments(p.oid)\n"+
				"  END AS \"%s\",\n",
			GettextNoop("Argument data types"))
	} else if d.version >= 80200 {
		fmt.Fprintf(w,
			"  CASE WHEN p.pronargs = 0\n"+
				"    THEN CAST('*' AS pg_catalog.text)\n"+
				"    ELSE\n"+
				"    pg_catalog.array_to_string(ARRAY(\n"+
				"      SELECT\n"+
				"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"+
				"      FROM\n"+
				"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"+
				"    ), ', ')\n"+
				"  END AS \"%s\",\n",
			GettextNoop("Argument data types"))
	} else {
		fmt.Fprintf(w,
			"  pg_catalog.format_type(p.proargtypes[0], NULL) AS \"%s\",\n",
			GettextNoop("Argument data types"))
	}

	if d.version >= 110000 {
		fmt.Fprintf(w,
			"  pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"\n"+
				"FROM pg_catalog.pg_proc p\n"+
				"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"+
				"WHERE p.prokind = 'a'\n",
			GettextNoop("Description"))
	} else {
		fmt.Fprintf(w,
			"  pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"\n"+
				"FROM pg_catalog.pg_proc p\n"+
				"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n"+
				"WHERE p.proisagg\n",
			GettextNoop("Description"))
	}

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "p.proname", NULL,
		"pg_catalog.pg_function_is_visible(p.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2, 4;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of aggregate functions");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Casts handles \dC.
//
// Generated from listCasts in psql's describe.c.
//
// \dC
//
// Describes casts.
func (d *PgDesc) Casts(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, false, true, false};

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT pg_catalog.format_type(castsource, NULL) AS \"%s\",\n"+
			"       pg_catalog.format_type(casttarget, NULL) AS \"%s\",\n",
		GettextNoop("Source type"),
		GettextNoop("Target type"))

	/*
	 * We don't attempt to localize '(binary coercible)' or '(with inout)',
	 * because there's too much risk of gettext translating a function name
	 * that happens to match some string in the PO database.
	 */
	if d.version >= 80400 {
		fmt.Fprintf(w,
			"       CASE WHEN c.castmethod = '%c' THEN '(binary coercible)'\n"+
				"            WHEN c.castmethod = '%c' THEN '(with inout)'\n"+
				"            ELSE p.proname\n"+
				"       END AS \"%s\",\n",
			COERCION_METHOD_BINARY,
			COERCION_METHOD_INOUT,
			GettextNoop("Function"))
	} else {
		fmt.Fprintf(w,
			"       CASE WHEN c.castfunc = 0 THEN '(binary coercible)'\n"+
				"            ELSE p.proname\n"+
				"       END AS \"%s\",\n",
			GettextNoop("Function"))
	}

	fmt.Fprintf(w,
		"       CASE WHEN c.castcontext = '%c' THEN '%s'\n"+
			"            WHEN c.castcontext = '%c' THEN '%s'\n"+
			"            ELSE '%s'\n"+
			"       END AS \"%s\"",
		COERCION_CODE_EXPLICIT,
		GettextNoop("no"),
		COERCION_CODE_ASSIGNMENT,
		GettextNoop("in assignment"),
		GettextNoop("yes"),
		GettextNoop("Implicit?"))

	if verbose {
		fmt.Fprintf(w,
			",\n       d.description AS \"%s\"",
			GettextNoop("Description"))
	}

	/*
	 * We need a left join to pg_proc for binary casts; the others are just
	 * paranoia.
	 */
	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_cast c LEFT JOIN pg_catalog.pg_proc p\n"+
			"     ON c.castfunc = p.oid\n"+
			"     LEFT JOIN pg_catalog.pg_type ts\n"+
			"     ON c.castsource = ts.oid\n"+
			"     LEFT JOIN pg_catalog.pg_namespace ns\n"+
			"     ON ns.oid = ts.typnamespace\n"+
			"     LEFT JOIN pg_catalog.pg_type tt\n"+
			"     ON c.casttarget = tt.oid\n"+
			"     LEFT JOIN pg_catalog.pg_namespace nt\n"+
			"     ON nt.oid = tt.typnamespace\n")

	if verbose {
		fmt.Fprint(w,
			"     LEFT JOIN pg_catalog.pg_description d\n"+
				"     ON d.classoid = c.tableoid AND d.objoid = "+
				"c.oid AND d.objsubid = 0\n")
	}

	fmt.Fprint(w, "WHERE ( (true")

	/*
	 * Match name pattern against either internal or external name of either
	 * castsource or casttarget
	 */
	processSQLNamePattern(w, pattern, true, false,
		"ns.nspname", "ts.typname",
		"pg_catalog.format_type(ts.oid, NULL)",
		"pg_catalog.pg_type_is_visible(ts.oid)")

	fmt.Fprint(w, ") OR (true")

	processSQLNamePattern(w, pattern, true, false,
		"nt.nspname", "tt.typname",
		"pg_catalog.format_type(tt.oid, NULL)",
		"pg_catalog.pg_type_is_visible(tt.oid)")

	fmt.Fprint(w, ") )\nORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of casts");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Collations handles \dO.
//
// Generated from listCollations in psql's describe.c.
//
// \dO
//
// Describes collations.
func (d *PgDesc) Collations(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, false, false, false, false};

	if d.version < 90100 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support collations.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname AS \"%s\",\n"+
			"       c.collname AS \"%s\",\n"+
			"       c.collcollate AS \"%s\",\n"+
			"       c.collctype AS \"%s\"",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Collate"),
		GettextNoop("Ctype"))

	if d.version >= 100000 {
		fmt.Fprintf(w,
			",\n       CASE c.collprovider WHEN 'd' THEN 'default' WHEN 'c' THEN 'libc' WHEN 'i' THEN 'icu' END AS \"%s\"",
			GettextNoop("Provider"))
	}

	if verbose {
		fmt.Fprintf(w,
			",\n       pg_catalog.obj_description(c.oid, 'pg_collation') AS \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n\n"+
			"WHERE n.oid = c.collnamespace\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	/*
	 * Hide collations that aren't usable in the current database's encoding.
	 * If you think to change this, note that pg_collation_is_visible rejects
	 * unusable collations, so you will need to hack name pattern processing
	 * somehow to avoid inconsistent behavior.
	 */
	fmt.Fprint(w, "      AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))\n")

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "c.collname", NULL,
		"pg_catalog.pg_collation_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of collations");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Conversions handles \dc.
//
// Generated from listConversions in psql's describe.c.
//
// \dc
//
// Describes conversions.
func (d *PgDesc) Conversions(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] =
	// {false, false, false, false, true, false};

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname AS \"%s\",\n"+
			"       c.conname AS \"%s\",\n"+
			"       pg_catalog.pg_encoding_to_char(c.conforencoding) AS \"%s\",\n"+
			"       pg_catalog.pg_encoding_to_char(c.contoencoding) AS \"%s\",\n"+
			"       CASE WHEN c.condefault THEN '%s'\n"+
			"       ELSE '%s' END AS \"%s\"",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Source"),
		GettextNoop("Destination"),
		GettextNoop("yes"), GettextNoop("no"),
		GettextNoop("Default?"))

	if verbose {
		fmt.Fprintf(w,
			",\n       d.description AS \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_conversion c\n"+
			"     JOIN pg_catalog.pg_namespace n "+
			"ON n.oid = c.connamespace\n")

	if verbose {
		fmt.Fprint(w,
			"LEFT JOIN pg_catalog.pg_description d "+
				"ON d.classoid = c.tableoid\n"+
				"          AND d.objoid = c.oid "+
				"AND d.objsubid = 0\n")
	}

	fmt.Fprint(w, "WHERE true\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "  AND n.nspname <> 'pg_catalog'\n"+
			"  AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "c.conname", NULL,
		"pg_catalog.pg_conversion_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of conversions");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// DatabaseRoleSettings handles \drds.
//
// Generated from listDbRoleSettings in psql's describe.c.
//
// \drds
func (d *PgDesc) DatabaseRoleSettings(w io.Writer, pattern string, pattern2 string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	var havewhere bool

	if d.version < 90000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support per-database role settings.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w, "SELECT rolname AS \"%s\", datname AS \"%s\",\n"+
		"pg_catalog.array_to_string(setconfig, E'\\n') AS \"%s\"\n"+
		"FROM pg_catalog.pg_db_role_setting s\n"+
		"LEFT JOIN pg_catalog.pg_database d ON d.oid = setdatabase\n"+
		"LEFT JOIN pg_catalog.pg_roles r ON r.oid = setrole\n",
		GettextNoop("Role"),
		GettextNoop("Database"),
		GettextNoop("Settings"))
	havewhere = processSQLNamePattern(w, pattern, false, false,
		NULL, "r.rolname", NULL, NULL)
	processSQLNamePattern(w, pattern2, havewhere, false,
		NULL, "d.datname", NULL, NULL)
	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// /*
	//  * Most functions in this file are content to print an empty table when
	//  * there are no matching objects.  We intentionally deviate from that
	//  * here, but only in !quiet mode, because of the possibility that the user
	//  * is confused about what the two pattern arguments mean.
	//  */
	// if (PQntuples(res) == 0 && !pset.quiet) {
	// 	if (pattern != NULL && pattern2 != NULL)
	// 		return fmt.Errorf("Did not find any settings for role \"%s\" and database \"%s\".\n",
	// 				   pattern, pattern2);
	// 	else if (pattern != NULL)
	// 		return fmt.Errorf("Did not find any settings for role \"%s\".\n",
	// 				   pattern);
	// 	else
	// 		return fmt.Errorf("Did not find any settings.\n");
	// }
	// else
	// {
	// 	myopt.nullPrint = NULL;
	// 	myopt.title = _("List of settings");
	// 	myopt.translate_header = true;

	// 	printQuery(res, &myopt, pset.queryFout, false, pset.logfile);
	// }

	// PQclear(res);
	// return true;
	return nil
}

// Databases handles \l.
//
// Generated from listAllDbs in psql's describe.c.
//
// listAllDbs
//
// for \l, \list, and -l switch
func (d *PgDesc) Databases(w io.Writer, pattern string, verbose bool) error {

	// PGresult   *res;
	// PQExpBufferData buf;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT d.datname as \"%s\",\n"+
			"       pg_catalog.pg_get_userbyid(d.datdba) as \"%s\",\n"+
			"       pg_catalog.pg_encoding_to_char(d.encoding) as \"%s\",\n",
		GettextNoop("Name"),
		GettextNoop("Owner"),
		GettextNoop("Encoding"))
	if d.version >= 80400 {
		fmt.Fprintf(w,
			"       d.datcollate as \"%s\",\n"+
				"       d.datctype as \"%s\",\n",
			GettextNoop("Collate"),
			GettextNoop("Ctype"))
	}
	fmt.Fprint(w, "       ")
	d.printACLColumn(w, "d.datacl")
	if verbose && d.version >= 80200 {
		fmt.Fprintf(w,
			",\n       CASE WHEN pg_catalog.has_database_privilege(d.datname, 'CONNECT')\n"+
				"            THEN pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))\n"+
				"            ELSE 'No Access'\n"+
				"       END as \"%s\"",
			GettextNoop("Size"))
	}
	if verbose && d.version >= 80000 {
		fmt.Fprintf(w,
			",\n       t.spcname as \"%s\"",
			GettextNoop("Tablespace"))
	}
	if verbose && d.version >= 80200 {
		fmt.Fprintf(w,
			",\n       pg_catalog.shobj_description(d.oid, 'pg_database') as \"%s\"",
			GettextNoop("Description"))
	}
	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_database d\n")
	if verbose && d.version >= 80000 {
		fmt.Fprint(w,
			"  JOIN pg_catalog.pg_tablespace t on d.dattablespace = t.oid\n")
	}

	if pattern != NULL {
		processSQLNamePattern(w, pattern, false, false,
			NULL, "d.datname", NULL, NULL)
	}

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of databases");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// DefaultACLS handles \ddp.
//
// Generated from listDefaultACLs in psql's describe.c.
//
// \ddp
//
// List Default ACLs.  The pattern can match either schema or role name.
func (d *PgDesc) DefaultACLS(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, true, false};

	if d.version < 90000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support altering default privileges.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT pg_catalog.pg_get_userbyid(d.defaclrole) AS \"%s\",\n"+
			"  n.nspname AS \"%s\",\n"+
			"  CASE d.defaclobjtype WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' WHEN '%c' THEN '%s' END AS \"%s\",\n"+
			"  ",
		GettextNoop("Owner"),
		GettextNoop("Schema"),
		DEFACLOBJ_RELATION,
		GettextNoop("table"),
		DEFACLOBJ_SEQUENCE,
		GettextNoop("sequence"),
		DEFACLOBJ_FUNCTION,
		GettextNoop("function"),
		DEFACLOBJ_TYPE,
		GettextNoop("type"),
		DEFACLOBJ_NAMESPACE,
		GettextNoop("schema"),
		GettextNoop("Type"))

	d.printACLColumn(w, "d.defaclacl")

	fmt.Fprint(w, "\nFROM pg_catalog.pg_default_acl d\n"+
		"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.defaclnamespace\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL,
		"n.nspname",
		"pg_catalog.pg_get_userbyid(d.defaclrole)",
		NULL)

	fmt.Fprint(w, "ORDER BY 1, 2, 3;")

	// res = PSQLexec(buf.data);
	// if (!res) {
	// 	termPQExpBuffer(w);
	// return false;
	// }

	// myopt.nullPrint = NULL;
	// fmt.Fprintf(w, _("Default access privileges"));
	// myopt.title = buf.data;
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// termPQExpBuffer(w);
	// PQclear(res);
	// return true;
	return nil
}

// Domains handles \dD.
//
// Generated from listDomains in psql's describe.c.
//
// \dD
//
// Describes domains.
func (d *PgDesc) Domains(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"       t.typname as \"%s\",\n"+
			"       pg_catalog.format_type(t.typbasetype, t.typtypmod) as \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Type"))

	if d.version >= 90100 {
		fmt.Fprintf(w,
			"       (SELECT c.collname FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt\n"+
				"        WHERE c.oid = t.typcollation AND bt.oid = t.typbasetype AND t.typcollation <> bt.typcollation) as \"%s\",\n",
			GettextNoop("Collation"))
	}
	fmt.Fprintf(w,
		"       CASE WHEN t.typnotnull THEN 'not null' END as \"%s\",\n"+
			"       t.typdefault as \"%s\",\n"+
			"       pg_catalog.array_to_string(ARRAY(\n"+
			"         SELECT pg_catalog.pg_get_constraintdef(r.oid, true) FROM pg_catalog.pg_constraint r WHERE t.oid = r.contypid\n"+
			"       ), ' ') as \"%s\"",
		GettextNoop("Nullable"),
		GettextNoop("Default"),
		GettextNoop("Check"))

	if verbose {
		if d.version >= 90200 {
			fmt.Fprint(w, ",\n  ")
			d.printACLColumn(w, "t.typacl")
		}
		fmt.Fprintf(w,
			",\n       d.description as \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_type t\n"+
			"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n")

	if verbose {
		fmt.Fprint(w,
			"     LEFT JOIN pg_catalog.pg_description d "+
				"ON d.classoid = t.tableoid AND d.objoid = t.oid "+
				"AND d.objsubid = 0\n")
	}

	fmt.Fprint(w, "WHERE t.typtype = 'd'\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "t.typname", NULL,
		"pg_catalog.pg_type_is_visible(t.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of domains");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// EventTriggers handles \dy.
//
// Generated from listEventTriggers in psql's describe.c.
//
// \dy
//
// Describes Event Triggers.
func (d *PgDesc) EventTriggers(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] =
	// {false, false, false, true, false, false, false};

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT evtname as \"%s\", "+
			"evtevent as \"%s\", "+
			"pg_catalog.pg_get_userbyid(e.evtowner) as \"%s\",\n"+
			" case evtenabled when 'O' then '%s'"+
			"  when 'R' then '%s'"+
			"  when 'A' then '%s'"+
			"  when 'D' then '%s' end as \"%s\",\n"+
			" e.evtfoid::pg_catalog.regproc as \"%s\", "+
			"pg_catalog.array_to_string(array(select x"+
			" from pg_catalog.unnest(evttags) as t(x)), ', ') as \"%s\"",
		GettextNoop("Name"),
		GettextNoop("Event"),
		GettextNoop("Owner"),
		GettextNoop("enabled"),
		GettextNoop("replica"),
		GettextNoop("always"),
		GettextNoop("disabled"),
		GettextNoop("Enabled"),
		GettextNoop("Function"),
		GettextNoop("Tags"))
	if verbose {
		fmt.Fprintf(w,
			",\npg_catalog.obj_description(e.oid, 'pg_event_trigger') as \"%s\"",
			GettextNoop("Description"))
	}
	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_event_trigger e ")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "evtname", NULL, NULL)

	fmt.Fprint(w, "ORDER BY 1")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of event triggers");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// ExtensionContents handles \dx+.
//
// Generated from listExtensionContents in psql's describe.c.
//
// \dx+
//
// List contents of installed extensions.
func (d *PgDesc) ExtensionContents(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// int			i;

	if d.version < 90100 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support extensions.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT e.extname, e.oid\n"+
			"FROM pg_catalog.pg_extension e\n")

	processSQLNamePattern(w, pattern,
		false, false,
		NULL, "e.extname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// if (PQntuples(res) == 0) {
	// 	if (!pset.quiet) {
	// 		if (pattern != NULL)
	// 			return fmt.Errorf("Did not find any extension named \"%s\".\n",
	// 					   pattern);
	// 		else
	// 			return fmt.Errorf("Did not find any extensions.\n");
	// 	}
	// 	PQclear(res);
	// return false;
	// }
	// for i := 0; i < PQntuples(res); i++ {
	// 	const char *extname;
	// 	const char *oid;

	// 	extname = PQgetvalue(res, i, 0);
	// 	oid = PQgetvalue(res, i, 1);

	// 	if (!d.OneExtensionContents(w, extname, oid)) {
	// 		PQclear(res);
	// return false;
	// 	}
	// 	if (cancel_pressed) {
	// 		PQclear(res);
	// return false;
	// 	}
	// }

	// PQclear(res);
	// return true;
	return nil
}

// Extensions handles \dx.
//
// Generated from listExtensions in psql's describe.c.
//
// \dx
//
// Briefly describes installed extensions.
func (d *PgDesc) Extensions(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 90100 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support extensions.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT e.extname AS \"%s\", "+
			"e.extversion AS \"%s\", n.nspname AS \"%s\", c.description AS \"%s\"\n"+
			"FROM pg_catalog.pg_extension e "+
			"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace "+
			"LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid "+
			"AND c.classoid = 'pg_catalog.pg_extension'::pg_catalog.regclass\n",
		GettextNoop("Name"),
		GettextNoop("Version"),
		GettextNoop("Schema"),
		GettextNoop("Description"))

	processSQLNamePattern(w, pattern,
		false, false,
		NULL, "e.extname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of installed extensions");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// ForeignDataWrappers handles \dew.
//
// Generated from listForeignDataWrappers in psql's describe.c.
//
// \dew
//
// Describes foreign-data wrappers
func (d *PgDesc) ForeignDataWrappers(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80400 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support foreign-data wrappers.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT fdw.fdwname AS \"%s\",\n"+
			"  pg_catalog.pg_get_userbyid(fdw.fdwowner) AS \"%s\",\n",
		GettextNoop("Name"),
		GettextNoop("Owner"))
	if d.version >= 90100 {
		fmt.Fprintf(w,
			"  fdw.fdwhandler::pg_catalog.regproc AS \"%s\",\n",
			GettextNoop("Handler"))
	}
	fmt.Fprintf(w,
		"  fdw.fdwvalidator::pg_catalog.regproc AS \"%s\"",
		GettextNoop("Validator"))

	if verbose {
		fmt.Fprint(w, ",\n  ")
		d.printACLColumn(w, "fdwacl")
		fmt.Fprintf(w,
			",\n CASE WHEN fdwoptions IS NULL THEN '' ELSE "+
				"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "+
				"  pg_catalog.quote_ident(option_name) ||  ' ' || "+
				"  pg_catalog.quote_literal(option_value)  FROM "+
				"  pg_catalog.pg_options_to_table(fdwoptions)),  ', ') || ')' "+
				"  END AS \"%s\"",
			GettextNoop("FDW options"))

		if d.version >= 90100 {
			fmt.Fprintf(w,
				",\n  d.description AS \"%s\" ",
				GettextNoop("Description"))
		}
	}

	fmt.Fprint(w, "\nFROM pg_catalog.pg_foreign_data_wrapper fdw\n")

	if verbose && d.version >= 90100 {
		fmt.Fprint(w,
			"LEFT JOIN pg_catalog.pg_description d\n"+
				"       ON d.classoid = fdw.tableoid "+
				"AND d.objoid = fdw.oid AND d.objsubid = 0\n")
	}

	processSQLNamePattern(w, pattern, false, false,
		NULL, "fdwname", NULL, NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of foreign-data wrappers");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// ForeignServers handles \des.
//
// Generated from listForeignServers in psql's describe.c.
//
// \des
//
// Describes foreign servers.
func (d *PgDesc) ForeignServers(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80400 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support foreign servers.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT s.srvname AS \"%s\",\n"+
			"  pg_catalog.pg_get_userbyid(s.srvowner) AS \"%s\",\n"+
			"  f.fdwname AS \"%s\"",
		GettextNoop("Name"),
		GettextNoop("Owner"),
		GettextNoop("Foreign-data wrapper"))

	if verbose {
		fmt.Fprint(w, ",\n  ")
		d.printACLColumn(w, "s.srvacl")
		fmt.Fprintf(w,
			",\n"+
				"  s.srvtype AS \"%s\",\n"+
				"  s.srvversion AS \"%s\",\n"+
				"  CASE WHEN srvoptions IS NULL THEN '' ELSE "+
				"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "+
				"  pg_catalog.quote_ident(option_name) ||  ' ' || "+
				"  pg_catalog.quote_literal(option_value)  FROM "+
				"  pg_catalog.pg_options_to_table(srvoptions)),  ', ') || ')' "+
				"  END AS \"%s\",\n"+
				"  d.description AS \"%s\"",
			GettextNoop("Type"),
			GettextNoop("Version"),
			GettextNoop("FDW options"),
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_foreign_server s\n"+
			"     JOIN pg_catalog.pg_foreign_data_wrapper f ON f.oid=s.srvfdw\n")

	if verbose {
		fmt.Fprint(w,
			"LEFT JOIN pg_catalog.pg_description d\n       "+
				"ON d.classoid = s.tableoid AND d.objoid = s.oid "+
				"AND d.objsubid = 0\n")
	}

	processSQLNamePattern(w, pattern, false, false,
		NULL, "s.srvname", NULL, NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of foreign servers");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// ForeignTables handles \det.
//
// Generated from listForeignTables in psql's describe.c.
//
// \det
//
// Describes foreign tables.
func (d *PgDesc) ForeignTables(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 90100 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support foreign tables.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT n.nspname AS \"%s\",\n"+
			"  c.relname AS \"%s\",\n"+
			"  s.srvname AS \"%s\"",
		GettextNoop("Schema"),
		GettextNoop("Table"),
		GettextNoop("Server"))

	if verbose {
		fmt.Fprintf(w,
			",\n CASE WHEN ftoptions IS NULL THEN '' ELSE "+
				"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "+
				"  pg_catalog.quote_ident(option_name) ||  ' ' || "+
				"  pg_catalog.quote_literal(option_value)  FROM "+
				"  pg_catalog.pg_options_to_table(ftoptions)),  ', ') || ')' "+
				"  END AS \"%s\",\n"+
				"  d.description AS \"%s\"",
			GettextNoop("FDW options"),
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_foreign_table ft\n"+
			"  INNER JOIN pg_catalog.pg_class c"+
			" ON c.oid = ft.ftrelid\n"+
			"  INNER JOIN pg_catalog.pg_namespace n"+
			" ON n.oid = c.relnamespace\n"+
			"  INNER JOIN pg_catalog.pg_foreign_server s"+
			" ON s.oid = ft.ftserver\n")
	if verbose {
		fmt.Fprint(w,
			"   LEFT JOIN pg_catalog.pg_description d\n"+
				"          ON d.classoid = c.tableoid AND "+
				"d.objoid = c.oid AND d.objsubid = 0\n")
	}

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "c.relname", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of foreign tables");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Functions handles \df, \dfa, \dfn, \dft, \dfw, etc.
//
// Generated from describeFunctions in psql's describe.c.
//
// \df
// Takes an optional regexp to select particular functions.
//
// As with \d, you can specify the kinds of functions you want:
//
// a for aggregates
// n for normal
// t for trigger
// w for window
//
// and you can mix and match these in any order.
func (d *PgDesc) Functions(w io.Writer, functypes string, pattern string, verbose bool, showSystem bool) error {

	var showAggregate bool = strchr(functypes, 'a') != NULL
	var showNormal bool = strchr(functypes, 'n') != NULL
	var showProcedure bool = strchr(functypes, 'p') != NULL
	var showTrigger bool = strchr(functypes, 't') != NULL
	var showWindow bool = strchr(functypes, 'w') != NULL
	var have_where bool
	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, false, false, true, true, true, false, true, false, false, false, false};

	/* No "Parallel" column before 9.6 */
	// static const bool translate_columns_pre_96[] = {false, false, false, false, true, true, false, true, false, false, false, false};

	if strlen(functypes) != strspn(functypes, "anptwS+") {
		return fmt.Errorf("\\df only takes [anptwS+] as options\n")
		// return true;
	}

	if showProcedure && d.version < 110000 {
		// char sverbuf[32];

		return fmt.Errorf("\\df does not take a \"%c\" option with server version %s\n",
			'p',
			d.sversion)
		// return true;
	}

	if !showAggregate && !showNormal && !showProcedure && !showTrigger && !showWindow {
		showAggregate, showNormal, showTrigger = true, true, true
		if d.version >= 110000 {
			showProcedure = true
		}
		if d.version >= 80400 {
			showWindow = true
		}
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  p.proname as \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"))

	if d.version >= 110000 {
		fmt.Fprintf(w,
			"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"+
				"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"+
				" CASE p.prokind\n"+
				"  WHEN 'a' THEN '%s'\n"+
				"  WHEN 'w' THEN '%s'\n"+
				"  WHEN 'p' THEN '%s'\n"+
				"  ELSE '%s'\n"+
				" END as \"%s\"",
			GettextNoop("Result data type"),
			GettextNoop("Argument data types"),
			/* translator: "agg" is short for "aggregate" */
			GettextNoop("agg"),
			GettextNoop("window"),
			GettextNoop("proc"),
			GettextNoop("func"),
			GettextNoop("Type"))
	} else if d.version >= 80400 {
		fmt.Fprintf(w,
			"  pg_catalog.pg_get_function_result(p.oid) as \"%s\",\n"+
				"  pg_catalog.pg_get_function_arguments(p.oid) as \"%s\",\n"+
				" CASE\n"+
				"  WHEN p.proisagg THEN '%s'\n"+
				"  WHEN p.proiswindow THEN '%s'\n"+
				"  WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"+
				"  ELSE '%s'\n"+
				" END as \"%s\"",
			GettextNoop("Result data type"),
			GettextNoop("Argument data types"),
			/* translator: "agg" is short for "aggregate" */
			GettextNoop("agg"),
			GettextNoop("window"),
			GettextNoop("trigger"),
			GettextNoop("func"),
			GettextNoop("Type"))
	} else if d.version >= 80100 {
		fmt.Fprintf(w,
			"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"+
				"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"+
				"  CASE WHEN proallargtypes IS NOT NULL THEN\n"+
				"    pg_catalog.array_to_string(ARRAY(\n"+
				"      SELECT\n"+
				"        CASE\n"+
				"          WHEN p.proargmodes[s.i] = 'i' THEN ''\n"+
				"          WHEN p.proargmodes[s.i] = 'o' THEN 'OUT '\n"+
				"          WHEN p.proargmodes[s.i] = 'b' THEN 'INOUT '\n"+
				"          WHEN p.proargmodes[s.i] = 'v' THEN 'VARIADIC '\n"+
				"        END ||\n"+
				"        CASE\n"+
				"          WHEN COALESCE(p.proargnames[s.i], '') = '' THEN ''\n"+
				"          ELSE p.proargnames[s.i] || ' '\n"+
				"        END ||\n"+
				"        pg_catalog.format_type(p.proallargtypes[s.i], NULL)\n"+
				"      FROM\n"+
				"        pg_catalog.generate_series(1, pg_catalog.array_upper(p.proallargtypes, 1)) AS s(i)\n"+
				"    ), ', ')\n"+
				"  ELSE\n"+
				"    pg_catalog.array_to_string(ARRAY(\n"+
				"      SELECT\n"+
				"        CASE\n"+
				"          WHEN COALESCE(p.proargnames[s.i+1], '') = '' THEN ''\n"+
				"          ELSE p.proargnames[s.i+1] || ' '\n"+
				"          END ||\n"+
				"        pg_catalog.format_type(p.proargtypes[s.i], NULL)\n"+
				"      FROM\n"+
				"        pg_catalog.generate_series(0, pg_catalog.array_upper(p.proargtypes, 1)) AS s(i)\n"+
				"    ), ', ')\n"+
				"  END AS \"%s\",\n"+
				"  CASE\n"+
				"    WHEN p.proisagg THEN '%s'\n"+
				"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"+
				"    ELSE '%s'\n"+
				"  END AS \"%s\"",
			GettextNoop("Result data type"),
			GettextNoop("Argument data types"),
			/* translator: "agg" is short for "aggregate" */
			GettextNoop("agg"),
			GettextNoop("trigger"),
			GettextNoop("func"),
			GettextNoop("Type"))
	} else {
		fmt.Fprintf(w,
			"  CASE WHEN p.proretset THEN 'SETOF ' ELSE '' END ||\n"+
				"  pg_catalog.format_type(p.prorettype, NULL) as \"%s\",\n"+
				"  pg_catalog.oidvectortypes(p.proargtypes) as \"%s\",\n"+
				"  CASE\n"+
				"    WHEN p.proisagg THEN '%s'\n"+
				"    WHEN p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype THEN '%s'\n"+
				"    ELSE '%s'\n"+
				"  END AS \"%s\"",
			GettextNoop("Result data type"),
			GettextNoop("Argument data types"),
			/* translator: "agg" is short for "aggregate" */
			GettextNoop("agg"),
			GettextNoop("trigger"),
			GettextNoop("func"),
			GettextNoop("Type"))
	}

	if verbose {
		fmt.Fprintf(w,
			",\n CASE\n"+
				"  WHEN p.provolatile = 'i' THEN '%s'\n"+
				"  WHEN p.provolatile = 's' THEN '%s'\n"+
				"  WHEN p.provolatile = 'v' THEN '%s'\n"+
				" END as \"%s\"",
			GettextNoop("immutable"),
			GettextNoop("stable"),
			GettextNoop("volatile"),
			GettextNoop("Volatility"))
		if d.version >= 90600 {
			fmt.Fprintf(w,
				",\n CASE\n"+
					"  WHEN p.proparallel = 'r' THEN '%s'\n"+
					"  WHEN p.proparallel = 's' THEN '%s'\n"+
					"  WHEN p.proparallel = 'u' THEN '%s'\n"+
					" END as \"%s\"",
				GettextNoop("restricted"),
				GettextNoop("safe"),
				GettextNoop("unsafe"),
				GettextNoop("Parallel"))
		}
		fmt.Fprintf(w,
			",\n pg_catalog.pg_get_userbyid(p.proowner) as \"%s\""+
				",\n CASE WHEN prosecdef THEN '%s' ELSE '%s' END AS \"%s\"",
			GettextNoop("Owner"),
			GettextNoop("definer"),
			GettextNoop("invoker"),
			GettextNoop("Security"))
		fmt.Fprint(w, ",\n ")
		d.printACLColumn(w, "p.proacl")
		fmt.Fprintf(w,
			",\n l.lanname as \"%s\""+
				",\n p.prosrc as \"%s\""+
				",\n pg_catalog.obj_description(p.oid, 'pg_proc') as \"%s\"",
			GettextNoop("Language"),
			GettextNoop("Source code"),
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_proc p"+
			"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\n")

	if verbose {
		fmt.Fprint(w,
			"     LEFT JOIN pg_catalog.pg_language l ON l.oid = p.prolang\n")
	}

	have_where = false

	/* filter by function type, if requested */
	if showNormal && showAggregate && showProcedure && showTrigger && showWindow {
		/* Do nothing */
	} else if showNormal {
		if !showAggregate {
			if have_where {
				fmt.Fprint(w, "      AND ")
			} else {
				fmt.Fprint(w, "WHERE ")
				have_where = true
			}
			if d.version >= 110000 {
				fmt.Fprint(w, "p.prokind <> 'a'\n")
			} else {
				fmt.Fprint(w, "NOT p.proisagg\n")
			}
		}
		if !showProcedure && d.version >= 110000 {
			if have_where {
				fmt.Fprint(w, "      AND ")
			} else {
				fmt.Fprint(w, "WHERE ")
				have_where = true
			}
			fmt.Fprint(w, "p.prokind <> 'p'\n")
		}
		if !showTrigger {
			if have_where {
				fmt.Fprint(w, "      AND ")
			} else {
				fmt.Fprint(w, "WHERE ")
				have_where = true
			}
			fmt.Fprint(w, "p.prorettype <> 'pg_catalog.trigger'::pg_catalog.regtype\n")
		}
		if !showWindow && d.version >= 80400 {
			if have_where {
				fmt.Fprint(w, "      AND ")
			} else {
				fmt.Fprint(w, "WHERE ")
				have_where = true
			}
			if d.version >= 110000 {
				fmt.Fprint(w, "p.prokind <> 'w'\n")
			} else {
				fmt.Fprint(w, "NOT p.proiswindow\n")
			}
		}
	} else {
		var needs_or bool

		fmt.Fprint(w, "WHERE (\n       ")
		have_where = true
		/* Note: at least one of these must be true ... */
		if showAggregate {
			if d.version >= 110000 {
				fmt.Fprint(w, "p.prokind = 'a'\n")
			} else {
				fmt.Fprint(w, "p.proisagg\n")
			}
			needs_or = true
		}
		if showTrigger {
			if needs_or {
				fmt.Fprint(w, "       OR ")
			}
			fmt.Fprint(w,
				"p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype\n")
			needs_or = true
		}
		if showProcedure {
			if needs_or {
				fmt.Fprint(w, "       OR ")
			}
			fmt.Fprint(w, "p.prokind = 'p'\n")
			needs_or = true
		}
		if showWindow {
			if needs_or {
				fmt.Fprint(w, "       OR ")
			}
			if d.version >= 110000 {
				fmt.Fprint(w, "p.prokind = 'w'\n")
			} else {
				fmt.Fprint(w, "p.proiswindow\n")
			}
			needs_or = true
		}
		fmt.Fprint(w, "      )\n")
	}

	processSQLNamePattern(w, pattern, have_where, false,
		"n.nspname", "p.proname", NULL,
		"pg_catalog.pg_function_is_visible(p.oid)")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	fmt.Fprint(w, "ORDER BY 1, 2, 4;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of functions");
	// myopt.translate_header = true;
	// if (d.version >= 90600) {
	// 	myopt.translate_columns = translate_columns;
	// 	myopt.n_translate_columns = lengthof(translate_columns);
	// }
	// else
	// {
	// 	myopt.translate_columns = translate_columns_pre_96;
	// 	myopt.n_translate_columns = lengthof(translate_columns_pre_96);
	// }

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Languages handles \dL.
//
// Generated from listLanguages in psql's describe.c.
//
// \dL
//
// Describes languages.
func (d *PgDesc) Languages(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT l.lanname AS \"%s\",\n",
		GettextNoop("Name"))
	if d.version >= 80300 {
		fmt.Fprintf(w,
			"       pg_catalog.pg_get_userbyid(l.lanowner) as \"%s\",\n",
			GettextNoop("Owner"))
	}

	fmt.Fprintf(w,
		"       l.lanpltrusted AS \"%s\"",
		GettextNoop("Trusted"))

	if verbose {
		fmt.Fprintf(w,
			",\n       NOT l.lanispl AS \"%s\",\n"+
				"       l.lanplcallfoid::pg_catalog.regprocedure AS \"%s\",\n"+
				"       l.lanvalidator::pg_catalog.regprocedure AS \"%s\",\n       ",
			GettextNoop("Internal language"),
			GettextNoop("Call handler"),
			GettextNoop("Validator"))
		if d.version >= 90000 {
			fmt.Fprintf(w, "l.laninline::pg_catalog.regprocedure AS \"%s\",\n       ",
				GettextNoop("Inline handler"))
		}
		d.printACLColumn(w, "l.lanacl")
	}

	fmt.Fprintf(w,
		",\n       d.description AS \"%s\""+
			"\nFROM pg_catalog.pg_language l\n"+
			"LEFT JOIN pg_catalog.pg_description d\n"+
			"  ON d.classoid = l.tableoid AND d.objoid = l.oid\n"+
			"  AND d.objsubid = 0\n",
		GettextNoop("Description"))

	if pattern != NULL {
		processSQLNamePattern(w, pattern, false, false,
			NULL, "l.lanname", NULL, NULL)
	}

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE l.lanplcallfoid != 0\n")
	}

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of languages");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// ObjectDescription handles \dd.
//
// Generated from objectDescription in psql's describe.c.
//
// Get object comments
//
// \dd [foo]
//
// Note: This command only lists comments for object types which do not have
// their comments displayed by their own backslash commands. The following
// types of objects will be displayed: constraint, operator class,
// operator family, rule, and trigger.
//
func (d *PgDesc) ObjectDescription(w io.Writer, pattern string, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, true, false};

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT DISTINCT tt.nspname AS \"%s\", tt.name AS \"%s\", tt.object AS \"%s\", d.description AS \"%s\"\n"+
			"FROM (\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Object"),
		GettextNoop("Description"))

	/* Table constraint descriptions */
	fmt.Fprintf(w,
		"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"+
			"  n.nspname as nspname,\n"+
			"  CAST(pgc.conname AS pg_catalog.text) as name,"+
			"  CAST('%s' AS pg_catalog.text) as object\n"+
			"  FROM pg_catalog.pg_constraint pgc\n"+
			"    JOIN pg_catalog.pg_class c "+
			"ON c.oid = pgc.conrelid\n"+
			"    LEFT JOIN pg_catalog.pg_namespace n "+
			"    ON n.oid = c.relnamespace\n",
		GettextNoop("table constraint"))

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, !showSystem && pattern != NULL,
		false, "n.nspname", "pgc.conname", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	/* Domain constraint descriptions */
	fmt.Fprintf(w,
		"UNION ALL\n"+
			"  SELECT pgc.oid as oid, pgc.tableoid AS tableoid,\n"+
			"  n.nspname as nspname,\n"+
			"  CAST(pgc.conname AS pg_catalog.text) as name,"+
			"  CAST('%s' AS pg_catalog.text) as object\n"+
			"  FROM pg_catalog.pg_constraint pgc\n"+
			"    JOIN pg_catalog.pg_type t "+
			"ON t.oid = pgc.contypid\n"+
			"    LEFT JOIN pg_catalog.pg_namespace n "+
			"    ON n.oid = t.typnamespace\n",
		GettextNoop("domain constraint"))

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, !showSystem && pattern != NULL,
		false, "n.nspname", "pgc.conname", NULL,
		"pg_catalog.pg_type_is_visible(t.oid)")

	/*
	 * pg_opclass.opcmethod only available in 8.3+
	 */
	if d.version >= 80300 {
		/* Operator class descriptions */
		fmt.Fprintf(w,
			"UNION ALL\n"+
				"  SELECT o.oid as oid, o.tableoid as tableoid,\n"+
				"  n.nspname as nspname,\n"+
				"  CAST(o.opcname AS pg_catalog.text) as name,\n"+
				"  CAST('%s' AS pg_catalog.text) as object\n"+
				"  FROM pg_catalog.pg_opclass o\n"+
				"    JOIN pg_catalog.pg_am am ON "+
				"o.opcmethod = am.oid\n"+
				"    JOIN pg_catalog.pg_namespace n ON "+
				"n.oid = o.opcnamespace\n",
			GettextNoop("operator class"))

		if !showSystem && pattern != NULL {
			fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
				"      AND n.nspname <> 'information_schema'\n")
		}

		processSQLNamePattern(w, pattern, true, false,
			"n.nspname", "o.opcname", NULL,
			"pg_catalog.pg_opclass_is_visible(o.oid)")
	}

	/*
	 * although operator family comments have been around since 8.3,
	 * pg_opfamily_is_visible is only available in 9.2+
	 */
	if d.version >= 90200 {
		/* Operator family descriptions */
		fmt.Fprintf(w,
			"UNION ALL\n"+
				"  SELECT opf.oid as oid, opf.tableoid as tableoid,\n"+
				"  n.nspname as nspname,\n"+
				"  CAST(opf.opfname AS pg_catalog.text) AS name,\n"+
				"  CAST('%s' AS pg_catalog.text) as object\n"+
				"  FROM pg_catalog.pg_opfamily opf\n"+
				"    JOIN pg_catalog.pg_am am "+
				"ON opf.opfmethod = am.oid\n"+
				"    JOIN pg_catalog.pg_namespace n "+
				"ON opf.opfnamespace = n.oid\n",
			GettextNoop("operator family"))

		if !showSystem && pattern != NULL {
			fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
				"      AND n.nspname <> 'information_schema'\n")
		}

		processSQLNamePattern(w, pattern, true, false,
			"n.nspname", "opf.opfname", NULL,
			"pg_catalog.pg_opfamily_is_visible(opf.oid)")
	}

	/* Rule descriptions (ignore rules for views) */
	fmt.Fprintf(w,
		"UNION ALL\n"+
			"  SELECT r.oid as oid, r.tableoid as tableoid,\n"+
			"  n.nspname as nspname,\n"+
			"  CAST(r.rulename AS pg_catalog.text) as name,"+
			"  CAST('%s' AS pg_catalog.text) as object\n"+
			"  FROM pg_catalog.pg_rewrite r\n"+
			"       JOIN pg_catalog.pg_class c ON c.oid = r.ev_class\n"+
			"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"+
			"  WHERE r.rulename != '_RETURN'\n",
		GettextNoop("rule"))

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "r.rulename", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	/* Trigger descriptions */
	fmt.Fprintf(w,
		"UNION ALL\n"+
			"  SELECT t.oid as oid, t.tableoid as tableoid,\n"+
			"  n.nspname as nspname,\n"+
			"  CAST(t.tgname AS pg_catalog.text) as name,"+
			"  CAST('%s' AS pg_catalog.text) as object\n"+
			"  FROM pg_catalog.pg_trigger t\n"+
			"       JOIN pg_catalog.pg_class c ON c.oid = t.tgrelid\n"+
			"       LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n",
		GettextNoop("trigger"))

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, !showSystem && pattern != NULL, false,
		"n.nspname", "t.tgname", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	fmt.Fprint(w,
		") AS tt\n"+
			"  JOIN pg_catalog.pg_description d ON (tt.oid = d.objoid AND tt.tableoid = d.classoid AND d.objsubid = 0)\n")

	fmt.Fprint(w, "ORDER BY 1, 2, 3;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("Object descriptions");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// OneExtensionContents handles [none].
//
// Generated from listOneExtensionContents in psql's describe.c.
//
// show one extension contents
func (d *PgDesc) OneExtensionContents(w io.Writer, extname string, oid string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// PQExpBufferData title;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT pg_catalog.pg_describe_object(classid, objid, 0) AS \"%s\"\n"+
			"FROM pg_catalog.pg_depend\n"+
			"WHERE refclassid = 'pg_catalog.pg_extension'::pg_catalog.regclass AND refobjid = '%s' AND deptype = 'e'\n"+
			"ORDER BY 1;",
		GettextNoop("Object description"),
		oid)

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// initPQExpBuffer(&title);
	// fmt.Fprintf(&title, _("Objects in extension \"%s\""), extname);
	// myopt.title = title.data;
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// termPQExpBuffer(&title);
	// PQclear(res);
	// return true;
	return nil
}

// OneTextSearchConfig handles [none].
//
// Generated from describeOneTSConfig in psql's describe.c.
//
// show one description of text search config
func (d *PgDesc) OneTextSearchConfig(w io.Writer, oid string, nspname string, cfgname string, pnspname string, prsname string) error {

	// PQExpBufferData buf,
	// 			title;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT\n"+
			"  ( SELECT t.alias FROM\n"+
			"    pg_catalog.ts_token_type(c.cfgparser) AS t\n"+
			"    WHERE t.tokid = m.maptokentype ) AS \"%s\",\n"+
			"  pg_catalog.btrim(\n"+
			"    ARRAY( SELECT mm.mapdict::pg_catalog.regdictionary\n"+
			"           FROM pg_catalog.pg_ts_config_map AS mm\n"+
			"           WHERE mm.mapcfg = m.mapcfg AND mm.maptokentype = m.maptokentype\n"+
			"           ORDER BY mapcfg, maptokentype, mapseqno\n"+
			"    ) :: pg_catalog.text,\n"+
			"  '{}') AS \"%s\"\n"+
			"FROM pg_catalog.pg_ts_config AS c, pg_catalog.pg_ts_config_map AS m\n"+
			"WHERE c.oid = '%s' AND m.mapcfg = c.oid\n"+
			"GROUP BY m.mapcfg, m.maptokentype, c.cfgparser\n"+
			"ORDER BY 1;",
		GettextNoop("Token"),
		GettextNoop("Dictionaries"),
		oid)

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// initPQExpBuffer(&title);

	// if (nspname)
	// 	fmt.Fprintf(&title, _("Text search configuration \"%s.%s\""),
	// 					  nspname, cfgname);
	// else
	// 	fmt.Fprintf(&title, _("Text search configuration \"%s\""),
	// 					  cfgname);

	// if (pnspname)
	// 	fmt.Fprintf(&title, _("\nParser: \"%s.%s\""),
	// 					  pnspname, prsname);
	// else
	// 	fmt.Fprintf(&title, _("\nParser: \"%s\""),
	// 					  prsname);

	// myopt.nullPrint = NULL;
	// myopt.title = title.data;
	// myopt.footers = NULL;
	// myopt.topt.default_footer = false;
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// termPQExpBuffer(&title);

	// PQclear(res);
	// return true;
	return nil
}

// OneTextSearchParser handles [none].
//
// Generated from describeOneTSParser in psql's describe.c.
//
// show one description of text search parser
func (d *PgDesc) OneTextSearchParser(w io.Writer, oid string, nspname string, prsname string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// PQExpBufferData title;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {true, false, false};

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT '%s' AS \"%s\",\n"+
			"   p.prsstart::pg_catalog.regproc AS \"%s\",\n"+
			"   pg_catalog.obj_description(p.prsstart, 'pg_proc') as \"%s\"\n"+
			" FROM pg_catalog.pg_ts_parser p\n"+
			" WHERE p.oid = '%s'\n"+
			"UNION ALL\n"+
			"SELECT '%s',\n"+
			"   p.prstoken::pg_catalog.regproc,\n"+
			"   pg_catalog.obj_description(p.prstoken, 'pg_proc')\n"+
			" FROM pg_catalog.pg_ts_parser p\n"+
			" WHERE p.oid = '%s'\n"+
			"UNION ALL\n"+
			"SELECT '%s',\n"+
			"   p.prsend::pg_catalog.regproc,\n"+
			"   pg_catalog.obj_description(p.prsend, 'pg_proc')\n"+
			" FROM pg_catalog.pg_ts_parser p\n"+
			" WHERE p.oid = '%s'\n"+
			"UNION ALL\n"+
			"SELECT '%s',\n"+
			"   p.prsheadline::pg_catalog.regproc,\n"+
			"   pg_catalog.obj_description(p.prsheadline, 'pg_proc')\n"+
			" FROM pg_catalog.pg_ts_parser p\n"+
			" WHERE p.oid = '%s'\n"+
			"UNION ALL\n"+
			"SELECT '%s',\n"+
			"   p.prslextype::pg_catalog.regproc,\n"+
			"   pg_catalog.obj_description(p.prslextype, 'pg_proc')\n"+
			" FROM pg_catalog.pg_ts_parser p\n"+
			" WHERE p.oid = '%s';",
		GettextNoop("Start parse"),
		GettextNoop("Method"),
		GettextNoop("Function"),
		GettextNoop("Description"),
		oid,
		GettextNoop("Get next token"),
		oid,
		GettextNoop("End parse"),
		oid,
		GettextNoop("Get headline"),
		oid,
		GettextNoop("Get token types"),
		oid)

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// initPQExpBuffer(&title);
	// if (nspname)
	// 	fmt.Fprintf(&title, _("Text search parser \"%s.%s\""),
	// 					  nspname, prsname);
	// else
	// 	fmt.Fprintf(&title, _("Text search parser \"%s\""), prsname);
	// myopt.title = title.data;
	// myopt.footers = NULL;
	// myopt.topt.default_footer = false;
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);

	// initPQExpBuffer(w);

	// fmt.Fprintf(w,
	// 				  "SELECT t.alias as \"%s\",\n"+
	// 				  "  t.description as \"%s\"\n"+
	// 				  "FROM pg_catalog.ts_token_type( '%s'::pg_catalog.oid ) as t\n"+
	// 				  "ORDER BY 1;",
	// 				  GettextNoop("Token name"),
	// 				  GettextNoop("Description"),
	// 				  oid);

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// if (nspname)
	// 	fmt.Fprintf(&title, _("Token types for parser \"%s.%s\""),
	// 					  nspname, prsname);
	// else
	// 	fmt.Fprintf(&title, _("Token types for parser \"%s\""), prsname);
	// myopt.title = title.data;
	// myopt.footers = NULL;
	// myopt.topt.default_footer = true;
	// myopt.translate_header = true;
	// myopt.translate_columns = NULL;
	// myopt.n_translate_columns = 0;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// termPQExpBuffer(&title);
	// PQclear(res);
	// return true;
	return nil
}

// Operators handles \do.
//
// Generated from describeOperators in psql's describe.c.
//
// \do
// Describe operators
func (d *PgDesc) Operators(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	/*
	 * Note: before Postgres 9.1, we did not assign comments to any built-in
	 * operators, preferring to let the comment on the underlying function
	 * suffice.  The coalesce() on the obj_description() calls below supports
	 * this convention by providing a fallback lookup of a comment on the
	 * operator's function.  As of 9.1 there is a policy that every built-in
	 * operator should have a comment; so the coalesce() is no longer
	 * necessary so far as built-in operators are concerned.  We keep it
	 * anyway, for now, because (1) third-party modules may still be following
	 * the old convention, and (2) we'd need to do it anyway when talking to a
	 * pre-9.1 server.
	 */

	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  o.oprname AS \"%s\",\n"+
			"  CASE WHEN o.oprkind='l' THEN NULL ELSE pg_catalog.format_type(o.oprleft, NULL) END AS \"%s\",\n"+
			"  CASE WHEN o.oprkind='r' THEN NULL ELSE pg_catalog.format_type(o.oprright, NULL) END AS \"%s\",\n"+
			"  pg_catalog.format_type(o.oprresult, NULL) AS \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Left arg type"),
		GettextNoop("Right arg type"),
		GettextNoop("Result type"))

	if verbose {
		fmt.Fprintf(w,
			"  o.oprcode AS \"%s\",\n",
			GettextNoop("Function"))
	}

	fmt.Fprintf(w,
		"  coalesce(pg_catalog.obj_description(o.oid, 'pg_operator'),\n"+
			"           pg_catalog.obj_description(o.oprcode, 'pg_proc')) AS \"%s\"\n"+
			"FROM pg_catalog.pg_operator o\n"+
			"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = o.oprnamespace\n",
		GettextNoop("Description"))

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, !showSystem && pattern != NULL, true,
		"n.nspname", "o.oprname", NULL,
		"pg_catalog.pg_operator_is_visible(o.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2, 3, 4;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of operators");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Permissions handles \z (or \dp).
//
// Generated from permissionsList in psql's describe.c.
//
// List Tables' Grant/Revoke Permissions
// \z (now also \dp -- perhaps more mnemonic)
func (d *PgDesc) Permissions(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, true, false, false, false};

	// initPQExpBuffer(w);

	/*
	 * we ignore indexes and toast tables since they have no meaningful rights
	 */
	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  c.relname as \"%s\",\n"+
			"  CASE c.relkind"+
			" WHEN '"+string(RELKIND_RELATION)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_VIEW)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_MATVIEW)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_SEQUENCE)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_FOREIGN_TABLE)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_PARTITIONED_TABLE)+"' THEN '%s'"+
			" END as \"%s\",\n"+
			"  ",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("table"),
		GettextNoop("view"),
		GettextNoop("materialized view"),
		GettextNoop("sequence"),
		GettextNoop("foreign table"),
		GettextNoop("partitioned table"),
		GettextNoop("Type"))

	d.printACLColumn(w, "c.relacl")

	if d.version >= 80400 {
		fmt.Fprintf(w,
			",\n  pg_catalog.array_to_string(ARRAY(\n"+
				"    SELECT attname || E':\\n  ' || pg_catalog.array_to_string(attacl, E'\\n  ')\n"+
				"    FROM pg_catalog.pg_attribute a\n"+
				"    WHERE attrelid = c.oid AND NOT attisdropped AND attacl IS NOT NULL\n"+
				"  ), E'\\n') AS \"%s\"",
			GettextNoop("Column privileges"))
	}

	if d.version >= 90500 && d.version < 100000 {
		fmt.Fprintf(w,
			",\n  pg_catalog.array_to_string(ARRAY(\n"+
				"    SELECT polname\n"+
				"    || CASE WHEN polcmd != '*' THEN\n"+
				"           E' (' || polcmd || E'):'\n"+
				"       ELSE E':'\n"+
				"       END\n"+
				"    || CASE WHEN polqual IS NOT NULL THEN\n"+
				"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"+
				"       ELSE E''\n"+
				"       END\n"+
				"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"+
				"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"+
				"       ELSE E''\n"+
				"       END"+
				"    || CASE WHEN polroles <> '{0}' THEN\n"+
				"           E'\\n  to: ' || pg_catalog.array_to_string(\n"+
				"               ARRAY(\n"+
				"                   SELECT rolname\n"+
				"                   FROM pg_catalog.pg_roles\n"+
				"                   WHERE oid = ANY (polroles)\n"+
				"                   ORDER BY 1\n"+
				"               ), E', ')\n"+
				"       ELSE E''\n"+
				"       END\n"+
				"    FROM pg_catalog.pg_policy pol\n"+
				"    WHERE polrelid = c.oid), E'\\n')\n"+
				"    AS \"%s\"",
			GettextNoop("Policies"))
	}

	if d.version >= 100000 {
		fmt.Fprintf(w,
			",\n  pg_catalog.array_to_string(ARRAY(\n"+
				"    SELECT polname\n"+
				"    || CASE WHEN NOT polpermissive THEN\n"+
				"       E' (RESTRICTIVE)'\n"+
				"       ELSE '' END\n"+
				"    || CASE WHEN polcmd != '*' THEN\n"+
				"           E' (' || polcmd || E'):'\n"+
				"       ELSE E':'\n"+
				"       END\n"+
				"    || CASE WHEN polqual IS NOT NULL THEN\n"+
				"           E'\\n  (u): ' || pg_catalog.pg_get_expr(polqual, polrelid)\n"+
				"       ELSE E''\n"+
				"       END\n"+
				"    || CASE WHEN polwithcheck IS NOT NULL THEN\n"+
				"           E'\\n  (c): ' || pg_catalog.pg_get_expr(polwithcheck, polrelid)\n"+
				"       ELSE E''\n"+
				"       END"+
				"    || CASE WHEN polroles <> '{0}' THEN\n"+
				"           E'\\n  to: ' || pg_catalog.array_to_string(\n"+
				"               ARRAY(\n"+
				"                   SELECT rolname\n"+
				"                   FROM pg_catalog.pg_roles\n"+
				"                   WHERE oid = ANY (polroles)\n"+
				"                   ORDER BY 1\n"+
				"               ), E', ')\n"+
				"       ELSE E''\n"+
				"       END\n"+
				"    FROM pg_catalog.pg_policy pol\n"+
				"    WHERE polrelid = c.oid), E'\\n')\n"+
				"    AS \"%s\"",
			GettextNoop("Policies"))
	}

	fmt.Fprint(w, "\nFROM pg_catalog.pg_class c\n"+
		"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n"+
		"WHERE c.relkind IN ("+
		"'"+string(RELKIND_RELATION)+"',"+
		"'"+string(RELKIND_VIEW)+"',"+
		"'"+string(RELKIND_MATVIEW)+"',"+
		"'"+string(RELKIND_SEQUENCE)+"',"+
		"'"+string(RELKIND_FOREIGN_TABLE)+"',"+
		"'"+string(RELKIND_PARTITIONED_TABLE)+"')\n")

	/*
	 * Unless a schema pattern is specified, we suppress system and temp
	 * tables, since they normally aren't very interesting from a permissions
	 * point of view.  You can see 'em by explicit request though, eg with \z
	 * pg_catalog.*
	 */
	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "c.relname", NULL,
		"n.nspname !~ '^pg_' AND pg_catalog.pg_table_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// if (!res) {
	// 	termPQExpBuffer(w);
	// return false;
	// }

	// myopt.nullPrint = NULL;
	// fmt.Fprintf(w, _("Access privileges"));
	// myopt.title = buf.data;
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// termPQExpBuffer(w);
	// PQclear(res);
	// return true;
	return nil
}

// PublicationDetails handles \dRp+.
//
// Generated from describePublications in psql's describe.c.
//
// \dRp+
// Describes publications including the contents.
//
// Takes an optional regexp to select particular publications
func (d *PgDesc) PublicationDetails(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// int			i;
	// PGresult   *res;
	var has_pubtruncate bool

	if d.version < 100000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support publications.\n",
			d.sversion)
		// return true;
	}

	has_pubtruncate = (d.version >= 110000)

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT oid, pubname,\n"+
			"  pg_catalog.pg_get_userbyid(pubowner) AS owner,\n"+
			"  puballtables, pubinsert, pubupdate, pubdelete")
	if has_pubtruncate {
		fmt.Fprintf(w,
			", pubtruncate")
	}
	fmt.Fprintf(w,
		"\nFROM pg_catalog.pg_publication\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "pubname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 2;")

	// res = PSQLexec(buf.data);
	// if (!res) {
	// 	termPQExpBuffer(w);
	// return false;
	// }

	// if (PQntuples(res) == 0) {
	// 	if (!pset.quiet) {
	// 		if (pattern != NULL)
	// 			return fmt.Errorf("Did not find any publication named \"%s\".\n",
	// 					   pattern);
	// 		else
	// 			return fmt.Errorf("Did not find any publications.\n");
	// 	}

	// 	termPQExpBuffer(w);
	// 	PQclear(res);
	// return false;
	// }
	// for i := 0; i < PQntuples(res); i++ {
	// 	const char	align = 'l';
	// 	int			ncols = 5;
	// 	int			nrows = 1;
	// 	int			tables = 0;
	// 	PGresult   *tabres;
	// 	char	   *pubid = PQgetvalue(res, i, 0);
	// 	char	   *pubname = PQgetvalue(res, i, 1);
	// 	bool		puballtables = strcmp(PQgetvalue(res, i, 3), "t") == 0;
	// 	int			j;
	// 	PQExpBufferData title;
	// 	printTableOpt myopt = pset.popt.topt;
	// 	printTableContent cont;

	// 	if (has_pubtruncate)
	// 		ncols++;

	// initPQExpBuffer(&title);
	// 	fmt.Fprintf(&title, _("Publication %s"), pubname);
	// 	printTableInit(&cont, &myopt, title.data, ncols, nrows);

	// 	printTableAddHeader(&cont, GettextNoop("Owner"), true, align);
	// 	printTableAddHeader(&cont, GettextNoop("All tables"), true, align);
	// 	printTableAddHeader(&cont, GettextNoop("Inserts"), true, align);
	// 	printTableAddHeader(&cont, GettextNoop("Updates"), true, align);
	// 	printTableAddHeader(&cont, GettextNoop("Deletes"), true, align);
	// 	if (has_pubtruncate)
	// 		printTableAddHeader(&cont, GettextNoop("Truncates"), true, align);

	// 	printTableAddCell(&cont, PQgetvalue(res, i, 2), false, false);
	// 	printTableAddCell(&cont, PQgetvalue(res, i, 3), false, false);
	// 	printTableAddCell(&cont, PQgetvalue(res, i, 4), false, false);
	// 	printTableAddCell(&cont, PQgetvalue(res, i, 5), false, false);
	// 	printTableAddCell(&cont, PQgetvalue(res, i, 6), false, false);
	// 	if (has_pubtruncate)
	// 		printTableAddCell(&cont, PQgetvalue(res, i, 7), false, false);

	// 	if (!puballtables) {
	// 		fmt.Fprintf(w,
	// 						  "SELECT n.nspname, c.relname\n"+
	// 						  "FROM pg_catalog.pg_class c,\n"+
	// 						  "     pg_catalog.pg_namespace n,\n"+
	// 						  "     pg_catalog.pg_publication_rel pr\n"+
	// 						  "WHERE c.relnamespace = n.oid\n"+
	// 						  "  AND c.oid = pr.prrelid\n"+
	// 						  "  AND pr.prpubid = '%s'\n"+
	// 						  "ORDER BY 1,2", pubid);

	// 		tabres = PSQLexec(buf.data);
	// 		if (!tabres) {
	// 			printTableCleanup(&cont);
	// 			PQclear(res);
	// 			termPQExpBuffer(w);
	// 			termPQExpBuffer(&title);
	// return false;
	// 		}
	// 		else
	// 			tables = PQntuples(tabres);

	// 		if (tables > 0)
	// 			printTableAddFooter(&cont, _("Tables:"));
	// for j := 0; j < tables; j++ {
	// 			fmt.Fprintf(w, "    \"%s.%s\"",
	// 							  PQgetvalue(tabres, j, 0),
	// 							  PQgetvalue(tabres, j, 1));

	// 			printTableAddFooter(&cont, buf.data);
	// 		}
	// 		PQclear(tabres);
	// 	}

	// 	printTable(&cont, pset.queryFout, false, pset.logfile);
	// 	printTableCleanup(&cont);

	// 	termPQExpBuffer(&title);
	// }

	// termPQExpBuffer(w);
	// PQclear(res);

	// return true;
	return nil
}

// Publications handles \dRp.
//
// Generated from listPublications in psql's describe.c.
//
// \dRp
// Lists publications.
//
// Takes an optional regexp to select particular publications
func (d *PgDesc) Publications(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, false, false, false, false, false};

	if d.version < 100000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support publications.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT pubname AS \"%s\",\n"+
			"  pg_catalog.pg_get_userbyid(pubowner) AS \"%s\",\n"+
			"  puballtables AS \"%s\",\n"+
			"  pubinsert AS \"%s\",\n"+
			"  pubupdate AS \"%s\",\n"+
			"  pubdelete AS \"%s\"",
		GettextNoop("Name"),
		GettextNoop("Owner"),
		GettextNoop("All tables"),
		GettextNoop("Inserts"),
		GettextNoop("Updates"),
		GettextNoop("Deletes"))
	if d.version >= 110000 {
		fmt.Fprintf(w,
			",\n  pubtruncate AS \"%s\"",
			GettextNoop("Truncates"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_publication\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "pubname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of publications");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);

	// return true;
	return nil
}

// Roles handles \du, \dg.
//
// Generated from describeRoles in psql's describe.c.
//
// \du or \dg
//
// Describes roles.  Any schema portion of the pattern is ignored.
func (d *PgDesc) Roles(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printTableContent cont;
	// printTableOpt myopt = pset.popt.topt;
	// int			ncols = 3;
	// int			nrows = 0;
	// int			i;
	// int			conns;
	// const char	align = 'l';
	// char	  **attr;

	// myopt.default_footer = false;

	// initPQExpBuffer(w);

	if d.version >= 80100 {
		fmt.Fprintf(w,
			"SELECT r.rolname, r.rolsuper, r.rolinherit,\n"+
				"  r.rolcreaterole, r.rolcreatedb, r.rolcanlogin,\n"+
				"  r.rolconnlimit, r.rolvaliduntil,\n"+
				"  ARRAY(SELECT b.rolname\n"+
				"        FROM pg_catalog.pg_auth_members m\n"+
				"        JOIN pg_catalog.pg_roles b ON (m.roleid = b.oid)\n"+
				"        WHERE m.member = r.oid) as memberof")

		if verbose && d.version >= 80200 {
			fmt.Fprint(w, "\n, pg_catalog.shobj_description(r.oid, 'pg_authid') AS description")
			// ncols++;
		}
		if d.version >= 90100 {
			fmt.Fprint(w, "\n, r.rolreplication")
		}

		if d.version >= 90500 {
			fmt.Fprint(w, "\n, r.rolbypassrls")
		}

		fmt.Fprint(w, "\nFROM pg_catalog.pg_roles r\n")

		if !showSystem && pattern != NULL {
			fmt.Fprint(w, "WHERE r.rolname !~ '^pg_'\n")
		}

		processSQLNamePattern(w, pattern, false, false,
			NULL, "r.rolname", NULL, NULL)
	} else {
		fmt.Fprintf(w,
			"SELECT u.usename AS rolname,\n"+
				"  u.usesuper AS rolsuper,\n"+
				"  true AS rolinherit, false AS rolcreaterole,\n"+
				"  u.usecreatedb AS rolcreatedb, true AS rolcanlogin,\n"+
				"  -1 AS rolconnlimit,"+
				"  u.valuntil as rolvaliduntil,\n"+
				"  ARRAY(SELECT g.groname FROM pg_catalog.pg_group g WHERE u.usesysid = ANY(g.grolist)) as memberof"+
				"\nFROM pg_catalog.pg_user u\n")

		processSQLNamePattern(w, pattern, false, false,
			NULL, "u.usename", NULL, NULL)
	}

	fmt.Fprint(w, "ORDER BY 1;")

	/* END */

	// res = PSQLexec(buf.data);
	// if (!res)
	// return false;

	// nrows = PQntuples(res);
	// attr = pg_malloc0((nrows + 1) * sizeof(*attr));

	// printTableInit(&cont, &myopt, _("List of roles"), ncols, nrows);

	// printTableAddHeader(&cont, GettextNoop("Role name"), true, align);
	// printTableAddHeader(&cont, GettextNoop("Attributes"), true, align);
	// printTableAddHeader(&cont, GettextNoop("Member of"), true, align);

	// if (verbose && d.version >= 80200)
	// 	printTableAddHeader(&cont, GettextNoop("Description"), true, align);
	// for i := 0; i < nrows; i++ {
	// 	printTableAddCell(&cont, PQgetvalue(res, i, 0), false, false);

	// 	resetPQExpBuffer(w);
	// 	if (strcmp(PQgetvalue(res, i, 1), "t") == 0)
	// 		add_role_attribute(w, _("Superuser"));

	// 	if (strcmp(PQgetvalue(res, i, 2), "t") != 0)
	// 		add_role_attribute(w, _("No inheritance"));

	// 	if (strcmp(PQgetvalue(res, i, 3), "t") == 0)
	// 		add_role_attribute(w, _("Create role"));

	// 	if (strcmp(PQgetvalue(res, i, 4), "t") == 0)
	// 		add_role_attribute(w, _("Create DB"));

	// 	if (strcmp(PQgetvalue(res, i, 5), "t") != 0)
	// 		add_role_attribute(w, _("Cannot login"));

	// 	if (d.version >= 90100)
	// 		if (strcmp(PQgetvalue(res, i, (verbose ? 10 : 9)), "t") == 0)
	// 			add_role_attribute(w, _("Replication"));

	// 	if (d.version >= 90500)
	// 		if (strcmp(PQgetvalue(res, i, (verbose ? 11 : 10)), "t") == 0)
	// 			add_role_attribute(w, _("Bypass RLS"));

	// 	conns = atoi(PQgetvalue(res, i, 6));
	// 	if (conns >= 0) {
	// 		if (buf.len > 0)
	// 			fmt.FprintfChar(w, '\n');

	// 		if (conns == 0)
	// 			fmt.Fprint(w, _("No connections"));
	// 		else
	// 			fmt.Fprintf(w, ngettext("%d connection",
	// 											 "%d connections",
	// 											 conns),
	// 							  conns);
	// 	}

	// 	if (strcmp(PQgetvalue(res, i, 7), "") != 0) {
	// 		if (buf.len > 0)
	// 			fmt.FprintfChar(w, '\n');
	// 		fmt.Fprint(w, _("Password valid until "));
	// 		fmt.Fprint(w, PQgetvalue(res, i, 7));
	// 	}

	// 	attr[i] = pg_strdup(buf.data);

	// 	printTableAddCell(&cont, attr[i], false, false);

	// 	printTableAddCell(&cont, PQgetvalue(res, i, 8), false, false);

	// 	if (verbose && d.version >= 80200)
	// 		printTableAddCell(&cont, PQgetvalue(res, i, 9), false, false);
	// }
	// termPQExpBuffer(w);

	// printTable(&cont, pset.queryFout, false, pset.logfile);
	// printTableCleanup(&cont);

	// for (i = 0; i < nrows; i++)
	// 	free(attr[i]);
	// free(attr);

	// PQclear(res);
	// return true;
	return nil
}

// Schemas handles \dn.
//
// Generated from listSchemas in psql's describe.c.
//
// \dn
//
// Describes schemas (namespaces)
func (d *PgDesc) Schemas(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT n.nspname AS \"%s\",\n"+
			"  pg_catalog.pg_get_userbyid(n.nspowner) AS \"%s\"",
		GettextNoop("Name"),
		GettextNoop("Owner"))

	if verbose {
		fmt.Fprint(w, ",\n  ")
		d.printACLColumn(w, "n.nspacl")
		fmt.Fprintf(w,
			",\n  pg_catalog.obj_description(n.oid, 'pg_namespace') AS \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprintf(w,
		"\nFROM pg_catalog.pg_namespace n\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w,
			"WHERE n.nspname !~ '^pg_' AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern,
		!showSystem && pattern != NULL, false,
		NULL, "n.nspname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of schemas");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Subscriptions handles \dRs.
//
// Generated from describeSubscriptions in psql's describe.c.
//
// \dRs
// Describes subscriptions.
//
// Takes an optional regexp to select particular subscriptions
func (d *PgDesc) Subscriptions(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, false, false,
	// false, false};

	if d.version < 100000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support subscriptions.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT subname AS \"%s\"\n"+
			",  pg_catalog.pg_get_userbyid(subowner) AS \"%s\"\n"+
			",  subenabled AS \"%s\"\n"+
			",  subpublications AS \"%s\"\n",
		GettextNoop("Name"),
		GettextNoop("Owner"),
		GettextNoop("Enabled"),
		GettextNoop("Publication"))

	if verbose {
		fmt.Fprintf(w,
			",  subsynccommit AS \"%s\"\n"+
				",  subconninfo AS \"%s\"\n",
			GettextNoop("Synchronous commit"),
			GettextNoop("Conninfo"))
	}

	/* Only display subscriptions in current database. */
	fmt.Fprint(w,
		"FROM pg_catalog.pg_subscription\n"+
			"WHERE subdbid = (SELECT oid\n"+
			"                 FROM pg_catalog.pg_database\n"+
			"                 WHERE datname = pg_catalog.current_database())")

	processSQLNamePattern(w, pattern, true, false,
		NULL, "subname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of subscriptions");
	// myopt.translate_header = true;
	// myopt.translate_columns = translate_columns;
	// myopt.n_translate_columns = lengthof(translate_columns);

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// TableDetails handles \d foo.
//
// Generated from describeTableDetails in psql's describe.c.
//
// describeTableDetails (for \d)
//
// This routine finds the tables to be displayed, and calls
// describeOneTableDetails for each one.
//
// verbose: if true, this is \d+
func (d *PgDesc) TableDetails(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// int			i;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT c.oid,\n"+
			"  n.nspname,\n"+
			"  c.relname\n"+
			"FROM pg_catalog.pg_class c\n"+
			"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "WHERE n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	processSQLNamePattern(w, pattern, !showSystem && pattern != NULL, false,
		"n.nspname", "c.relname", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 2, 3;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// if (PQntuples(res) == 0) {
	// 	if (!pset.quiet) {
	// 		if (pattern != NULL)
	// 			return fmt.Errorf("Did not find any relation named \"%s\".\n",
	// 					   pattern);
	// 		else
	// 			return fmt.Errorf("Did not find any relations.\n");
	// 	}
	// 	PQclear(res);
	// return false;
	// }
	// for i := 0; i < PQntuples(res); i++ {
	// 	const char *oid;
	// 	const char *nspname;
	// 	const char *relname;

	// 	oid = PQgetvalue(res, i, 0);
	// 	nspname = PQgetvalue(res, i, 1);
	// 	relname = PQgetvalue(res, i, 2);

	// 	if (!describeOneTableDetails(nspname, relname, oid, verbose)) {
	// 		PQclear(res);
	// return false;
	// 	}
	// 	if (cancel_pressed) {
	// 		PQclear(res);
	// return false;
	// 	}
	// }

	// PQclear(res);
	// return true;
	return nil
}

// Tables handles \dt, \di, \ds, \dS, etc.
//
// Generated from listTables in psql's describe.c.
//
// listTables()
//
// handler for \dt, \di, etc.
//
// tabtypes is an array of characters, specifying what info is desired:
// t - tables
// i - indexes
// v - views
// m - materialized views
// s - sequences
// E - foreign table (Note: different from 'f', the relkind value)
// (any order of the above is fine)
func (d *PgDesc) Tables(w io.Writer, tabtypes string, pattern string, verbose bool, showSystem bool) error {

	var showTables bool = strchr(tabtypes, 't') != NULL
	var showIndexes bool = strchr(tabtypes, 'i') != NULL
	var showViews bool = strchr(tabtypes, 'v') != NULL
	var showMatViews bool = strchr(tabtypes, 'm') != NULL
	var showSeq bool = strchr(tabtypes, 's') != NULL
	var showForeign bool = strchr(tabtypes, 'E') != NULL

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;
	// static const bool translate_columns[] = {false, false, true, false, false, false, false};

	/* If tabtypes is empty, we default to \dtvmsE (but see also command.c) */
	if !(showTables || showIndexes || showViews || showMatViews || showSeq || showForeign) {
		showTables, showViews, showMatViews, showSeq, showForeign = true, true, true, true, true
	}

	// initPQExpBuffer(w);

	/*
	 * Note: as of Pg 8.2, we no longer use relkind 's' (special), but we keep
	 * it here for backwards compatibility.
	 */
	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  c.relname as \"%s\",\n"+
			"  CASE c.relkind"+
			" WHEN '"+string(RELKIND_RELATION)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_VIEW)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_MATVIEW)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_INDEX)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_SEQUENCE)+"' THEN '%s'"+
			" WHEN 's' THEN '%s'"+
			" WHEN '"+string(RELKIND_FOREIGN_TABLE)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_PARTITIONED_TABLE)+"' THEN '%s'"+
			" WHEN '"+string(RELKIND_PARTITIONED_INDEX)+"' THEN '%s'"+
			" END as \"%s\",\n"+
			"  pg_catalog.pg_get_userbyid(c.relowner) as \"%s\"",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("table"),
		GettextNoop("view"),
		GettextNoop("materialized view"),
		GettextNoop("index"),
		GettextNoop("sequence"),
		GettextNoop("special"),
		GettextNoop("foreign table"),
		GettextNoop("partitioned table"),
		GettextNoop("partitioned index"),
		GettextNoop("Type"),
		GettextNoop("Owner"))

	if showIndexes {
		fmt.Fprintf(w,
			",\n c2.relname as \"%s\"",
			GettextNoop("Table"))
	}

	if verbose {
		/*
		 * As of PostgreSQL 9.0, use pg_table_size() to show a more accurate
		 * size of a table, including FSM, VM and TOAST tables.
		 */
		if d.version >= 90000 {
			fmt.Fprintf(w,
				",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_table_size(c.oid)) as \"%s\"",
				GettextNoop("Size"))
		} else if d.version >= 80100 {
			fmt.Fprintf(w,
				",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_relation_size(c.oid)) as \"%s\"",
				GettextNoop("Size"))
		}

		fmt.Fprintf(w,
			",\n  pg_catalog.obj_description(c.oid, 'pg_class') as \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_class c"+
			"\n     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace")
	if showIndexes {
		fmt.Fprint(w,
			"\n     LEFT JOIN pg_catalog.pg_index i ON i.indexrelid = c.oid"+
				"\n     LEFT JOIN pg_catalog.pg_class c2 ON i.indrelid = c2.oid")
	}

	fmt.Fprint(w, "\nWHERE c.relkind IN (")
	if showTables {
		fmt.Fprint(w, "'"+string(RELKIND_RELATION)+"',"+
			"'"+string(RELKIND_PARTITIONED_TABLE)+"',")
	}
	if showViews {
		fmt.Fprint(w, "'"+string(RELKIND_VIEW)+"',")
	}
	if showMatViews {
		fmt.Fprint(w, "'"+string(RELKIND_MATVIEW)+"',")
	}
	if showIndexes {
		fmt.Fprint(w, "'"+string(RELKIND_INDEX)+"',"+
			"'"+string(RELKIND_PARTITIONED_INDEX)+"',")
	}
	if showSeq {
		fmt.Fprint(w, "'"+string(RELKIND_SEQUENCE)+"',")
	}
	if showSystem || pattern != NULL {
		fmt.Fprint(w, "'s',") /* was RELKIND_SPECIAL */
	}
	if showForeign {
		fmt.Fprint(w, "'"+string(RELKIND_FOREIGN_TABLE)+"',")
	}

	fmt.Fprint(w, "''") /* dummy */
	fmt.Fprint(w, ")\n")

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")
	}

	/*
	 * TOAST objects are suppressed unconditionally.  Since we don't provide
	 * any way to select RELKIND_TOASTVALUE above, we would never show toast
	 * tables in any case; it seems a bit confusing to allow their indexes to
	 * be shown.  Use plain \d if you really need to look at a TOAST
	 * table/index.
	 */
	fmt.Fprint(w, "      AND n.nspname !~ '^pg_toast'\n")

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "c.relname", NULL,
		"pg_catalog.pg_table_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1,2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// /*
	//  * Most functions in this file are content to print an empty table when
	//  * there are no matching objects.  We intentionally deviate from that
	//  * here, but only in !quiet mode, for historical reasons.
	//  */
	// if (PQntuples(res) == 0 && !pset.quiet) {
	// 	if (pattern != NULL)
	// 		return fmt.Errorf("Did not find any relation named \"%s\".\n",
	// 				   pattern);
	// 	else
	// 		return fmt.Errorf("Did not find any relations.\n");
	// }
	// else
	// {
	// 	myopt.nullPrint = NULL;
	// 	myopt.title = _("List of relations");
	// 	myopt.translate_header = true;
	// 	myopt.translate_columns = translate_columns;
	// 	myopt.n_translate_columns = lengthof(translate_columns);

	// 	printQuery(res, &myopt, pset.queryFout, false, pset.logfile);
	// }

	// PQclear(res);
	// return true;
	return nil
}

// Tablespaces handles \db.
//
// Generated from describeTablespaces in psql's describe.c.
//
// \db
// Takes an optional regexp to select particular tablespaces
func (d *PgDesc) Tablespaces(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80000 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support tablespaces.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	if d.version >= 90200 {
		fmt.Fprintf(w,
			"SELECT spcname AS \"%s\",\n"+
				"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"+
				"  pg_catalog.pg_tablespace_location(oid) AS \"%s\"",
			GettextNoop("Name"),
			GettextNoop("Owner"),
			GettextNoop("Location"))
	} else {
		fmt.Fprintf(w,
			"SELECT spcname AS \"%s\",\n"+
				"  pg_catalog.pg_get_userbyid(spcowner) AS \"%s\",\n"+
				"  spclocation AS \"%s\"",
			GettextNoop("Name"),
			GettextNoop("Owner"),
			GettextNoop("Location"))
	}

	if verbose {
		fmt.Fprint(w, ",\n  ")
		d.printACLColumn(w, "spcacl")
	}

	if verbose && d.version >= 90000 {
		fmt.Fprintf(w,
			",\n  spcoptions AS \"%s\"",
			GettextNoop("Options"))
	}

	if verbose && d.version >= 90200 {
		fmt.Fprintf(w,
			",\n  pg_catalog.pg_size_pretty(pg_catalog.pg_tablespace_size(oid)) AS \"%s\"",
			GettextNoop("Size"))
	}

	if verbose && d.version >= 80200 {
		fmt.Fprintf(w,
			",\n  pg_catalog.shobj_description(oid, 'pg_tablespace') AS \"%s\"",
			GettextNoop("Description"))
	}

	fmt.Fprint(w,
		"\nFROM pg_catalog.pg_tablespace\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "spcname", NULL,
		NULL)

	fmt.Fprint(w, "ORDER BY 1;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of tablespaces");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchConfigs handles \dF.
//
// Generated from listTSConfigs in psql's describe.c.
//
// \dF
// list text search configurations
func (d *PgDesc) TextSearchConfigs(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80300 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support full text search.\n",
			d.sversion)
		// return true;
	}

	if verbose {
		return d.TextSearchConfigsVerbose(w, pattern)
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT\n"+
			"   n.nspname as \"%s\",\n"+
			"   c.cfgname as \"%s\",\n"+
			"   pg_catalog.obj_description(c.oid, 'pg_ts_config') as \"%s\"\n"+
			"FROM pg_catalog.pg_ts_config c\n"+
			"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Description"))

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "c.cfgname", NULL,
		"pg_catalog.pg_ts_config_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of text search configurations");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchConfigsVerbose handles [none].
//
// Generated from listTSConfigsVerbose in psql's describe.c.
//
// full description of configs
func (d *PgDesc) TextSearchConfigsVerbose(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// int			i;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT c.oid, c.cfgname,\n"+
			"   n.nspname,\n"+
			"   p.prsname,\n"+
			"   np.nspname as pnspname\n"+
			"FROM pg_catalog.pg_ts_config c\n"+
			"   LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.cfgnamespace,\n"+
			" pg_catalog.pg_ts_parser p\n"+
			"   LEFT JOIN pg_catalog.pg_namespace np ON np.oid = p.prsnamespace\n"+
			"WHERE  p.oid = c.cfgparser\n")

	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "c.cfgname", NULL,
		"pg_catalog.pg_ts_config_is_visible(c.oid)")

	fmt.Fprint(w, "ORDER BY 3, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// if (PQntuples(res) == 0) {
	// 	if (!pset.quiet) {
	// 		if (pattern != NULL)
	// 			return fmt.Errorf("Did not find any text search configuration named \"%s\".\n",
	// 					   pattern);
	// 		else
	// 			return fmt.Errorf("Did not find any text search configurations.\n");
	// 	}
	// 	PQclear(res);
	// return false;
	// }
	// for i := 0; i < PQntuples(res); i++ {
	// 	const char *oid;
	// 	const char *cfgname;
	// 	const char *nspname = NULL;
	// 	const char *prsname;
	// 	const char *pnspname = NULL;

	// 	oid = PQgetvalue(res, i, 0);
	// 	cfgname = PQgetvalue(res, i, 1);
	// 	if (!PQgetisnull(res, i, 2))
	// 		nspname = PQgetvalue(res, i, 2);
	// 	prsname = PQgetvalue(res, i, 3);
	// 	if (!PQgetisnull(res, i, 4))
	// 		pnspname = PQgetvalue(res, i, 4);

	// 	if (!d.OneTextSearchConfig(w, oid, nspname, cfgname, pnspname, prsname)) {
	// 		PQclear(res);
	// return false;
	// 	}

	// 	if (cancel_pressed) {
	// 		PQclear(res);
	// return false;
	// 	}
	// }

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchDictionaries handles \dFd.
//
// Generated from listTSDictionaries in psql's describe.c.
//
// \dFd
// list text search dictionaries
func (d *PgDesc) TextSearchDictionaries(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80300 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support full text search.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT\n"+
			"  n.nspname as \"%s\",\n"+
			"  d.dictname as \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"))

	if verbose {
		fmt.Fprintf(w,
			"  ( SELECT COALESCE(nt.nspname, '(null)')::pg_catalog.text || '.' || t.tmplname FROM\n"+
				"    pg_catalog.pg_ts_template t\n"+
				"    LEFT JOIN pg_catalog.pg_namespace nt ON nt.oid = t.tmplnamespace\n"+
				"    WHERE d.dicttemplate = t.oid ) AS  \"%s\",\n"+
				"  d.dictinitoption as \"%s\",\n",
			GettextNoop("Template"),
			GettextNoop("Init options"))
	}

	fmt.Fprintf(w,
		"  pg_catalog.obj_description(d.oid, 'pg_ts_dict') as \"%s\"\n",
		GettextNoop("Description"))

	fmt.Fprint(w, "FROM pg_catalog.pg_ts_dict d\n"+
		"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = d.dictnamespace\n")

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "d.dictname", NULL,
		"pg_catalog.pg_ts_dict_is_visible(d.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of text search dictionaries");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchParsers handles \dFp.
//
// Generated from listTSParsers in psql's describe.c.
//
// \dFp
// list text search parsers
func (d *PgDesc) TextSearchParsers(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80300 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support full text search.\n",
			d.sversion)
		// return true;
	}

	if verbose {
		return d.TextSearchParsersVerbose(w, pattern)
	}

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT\n"+
			"  n.nspname as \"%s\",\n"+
			"  p.prsname as \"%s\",\n"+
			"  pg_catalog.obj_description(p.oid, 'pg_ts_parser') as \"%s\"\n"+
			"FROM pg_catalog.pg_ts_parser p\n"+
			"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n",
		GettextNoop("Schema"),
		GettextNoop("Name"),
		GettextNoop("Description"))

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "p.prsname", NULL,
		"pg_catalog.pg_ts_parser_is_visible(p.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of text search parsers");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchParsersVerbose handles [none].
//
// Generated from listTSParsersVerbose in psql's describe.c.
//
// full description of parsers
func (d *PgDesc) TextSearchParsersVerbose(w io.Writer, pattern string) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// int			i;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT p.oid,\n"+
			"  n.nspname,\n"+
			"  p.prsname\n"+
			"FROM pg_catalog.pg_ts_parser p\n"+
			"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.prsnamespace\n")

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "p.prsname", NULL,
		"pg_catalog.pg_ts_parser_is_visible(p.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// if (PQntuples(res) == 0) {
	// 	if (!pset.quiet) {
	// 		if (pattern != NULL)
	// 			return fmt.Errorf("Did not find any text search parser named \"%s\".\n",
	// 					   pattern);
	// 		else
	// 			return fmt.Errorf("Did not find any text search parsers.\n");
	// 	}
	// 	PQclear(res);
	// return false;
	// }
	// for i := 0; i < PQntuples(res); i++ {
	// 	const char *oid;
	// 	const char *nspname = NULL;
	// 	const char *prsname;

	// 	oid = PQgetvalue(res, i, 0);
	// 	if (!PQgetisnull(res, i, 1))
	// 		nspname = PQgetvalue(res, i, 1);
	// 	prsname = PQgetvalue(res, i, 2);

	// 	if (!d.OneTextSearchParser(w, oid, nspname, prsname)) {
	// 		PQclear(res);
	// return false;
	// 	}

	// 	if (cancel_pressed) {
	// 		PQclear(res);
	// return false;
	// 	}
	// }

	// PQclear(res);
	// return true;
	return nil
}

// TextSearchTemplates handles \dFt.
//
// Generated from listTSTemplates in psql's describe.c.
//
// \dFt
// list text search templates
func (d *PgDesc) TextSearchTemplates(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80300 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support full text search.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);

	if verbose {
		fmt.Fprintf(w,
			"SELECT\n"+
				"  n.nspname AS \"%s\",\n"+
				"  t.tmplname AS \"%s\",\n"+
				"  t.tmplinit::pg_catalog.regproc AS \"%s\",\n"+
				"  t.tmpllexize::pg_catalog.regproc AS \"%s\",\n"+
				"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n",
			GettextNoop("Schema"),
			GettextNoop("Name"),
			GettextNoop("Init"),
			GettextNoop("Lexize"),
			GettextNoop("Description"))
	} else {
		fmt.Fprintf(w,
			"SELECT\n"+
				"  n.nspname AS \"%s\",\n"+
				"  t.tmplname AS \"%s\",\n"+
				"  pg_catalog.obj_description(t.oid, 'pg_ts_template') AS \"%s\"\n",
			GettextNoop("Schema"),
			GettextNoop("Name"),
			GettextNoop("Description"))
	}

	fmt.Fprint(w, "FROM pg_catalog.pg_ts_template t\n"+
		"LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.tmplnamespace\n")

	processSQLNamePattern(w, pattern, false, false,
		"n.nspname", "t.tmplname", NULL,
		"pg_catalog.pg_ts_template_is_visible(t.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of text search templates");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// Types handles \dT.
//
// Generated from describeTypes in psql's describe.c.
//
// \dT
// describe types
func (d *PgDesc) Types(w io.Writer, pattern string, verbose bool, showSystem bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	// initPQExpBuffer(w);

	fmt.Fprintf(w,
		"SELECT n.nspname as \"%s\",\n"+
			"  pg_catalog.format_type(t.oid, NULL) AS \"%s\",\n",
		GettextNoop("Schema"),
		GettextNoop("Name"))
	if verbose {
		fmt.Fprintf(w,
			"  t.typname AS \"%s\",\n"+
				"  CASE WHEN t.typrelid != 0\n"+
				"      THEN CAST('tuple' AS pg_catalog.text)\n"+
				"    WHEN t.typlen < 0\n"+
				"      THEN CAST('var' AS pg_catalog.text)\n"+
				"    ELSE CAST(t.typlen AS pg_catalog.text)\n"+
				"  END AS \"%s\",\n",
			GettextNoop("Internal name"),
			GettextNoop("Size"))
	}
	if verbose && d.version >= 80300 {
		fmt.Fprint(w,
			"  pg_catalog.array_to_string(\n"+
				"      ARRAY(\n"+
				"          SELECT e.enumlabel\n"+
				"          FROM pg_catalog.pg_enum e\n"+
				"          WHERE e.enumtypid = t.oid\n")

		if d.version >= 90100 {
			fmt.Fprint(w,
				"          ORDER BY e.enumsortorder\n")
		} else {
			fmt.Fprint(w,
				"          ORDER BY e.oid\n")
		}

		fmt.Fprintf(w,
			"      ),\n"+
				"      E'\\n'\n"+
				"  ) AS \"%s\",\n",
			GettextNoop("Elements"))
	}
	if verbose {
		fmt.Fprintf(w,
			"  pg_catalog.pg_get_userbyid(t.typowner) AS \"%s\",\n",
			GettextNoop("Owner"))
	}
	if verbose && d.version >= 90200 {
		d.printACLColumn(w, "t.typacl")
		fmt.Fprint(w, ",\n  ")
	}

	fmt.Fprintf(w,
		"  pg_catalog.obj_description(t.oid, 'pg_type') as \"%s\"\n",
		GettextNoop("Description"))

	fmt.Fprint(w, "FROM pg_catalog.pg_type t\n"+
		"     LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\n")

	/*
	 * do not include complex types (typrelid!=0) unless they are standalone
	 * composite types
	 */
	fmt.Fprint(w, "WHERE (t.typrelid = 0 ")
	fmt.Fprint(w, "OR (SELECT c.relkind = '"+string(RELKIND_COMPOSITE_TYPE)+"'"+
		" FROM pg_catalog.pg_class c "+
		"WHERE c.oid = t.typrelid))\n")

	/*
	 * do not include array types (before 8.3 we have to use the assumption
	 * that their names start with underscore)
	 */
	if d.version >= 80300 {
		fmt.Fprint(w, "  AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)\n")
	} else {
		fmt.Fprint(w, "  AND t.typname !~ '^_'\n")
	}

	if !showSystem && pattern != NULL {
		fmt.Fprint(w, "      AND n.nspname <> 'pg_catalog'\n"+
			"      AND n.nspname <> 'information_schema'\n")

		/* Match name pattern against either internal or external name */
	}
	processSQLNamePattern(w, pattern, true, false,
		"n.nspname", "t.typname",
		"pg_catalog.format_type(t.oid, NULL)",
		"pg_catalog.pg_type_is_visible(t.oid)")

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of data types");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}

// UserMappings handles \deu.
//
// Generated from listUserMappings in psql's describe.c.
//
// \deu
//
// Describes user mappings.
func (d *PgDesc) UserMappings(w io.Writer, pattern string, verbose bool) error {

	// PQExpBufferData buf;
	// PGresult   *res;
	// printQueryOpt myopt = pset.popt;

	if d.version < 80400 {
		// char sverbuf[32];

		return fmt.Errorf("The server (version %s) does not support user mappings.\n",
			d.sversion)
		// return true;
	}

	// initPQExpBuffer(w);
	fmt.Fprintf(w,
		"SELECT um.srvname AS \"%s\",\n"+
			"  um.usename AS \"%s\"",
		GettextNoop("Server"),
		GettextNoop("User name"))

	if verbose {
		fmt.Fprintf(w,
			",\n CASE WHEN umoptions IS NULL THEN '' ELSE "+
				"  '(' || pg_catalog.array_to_string(ARRAY(SELECT "+
				"  pg_catalog.quote_ident(option_name) ||  ' ' || "+
				"  pg_catalog.quote_literal(option_value)  FROM "+
				"  pg_catalog.pg_options_to_table(umoptions)),  ', ') || ')' "+
				"  END AS \"%s\"",
			GettextNoop("FDW options"))
	}

	fmt.Fprint(w, "\nFROM pg_catalog.pg_user_mappings um\n")

	processSQLNamePattern(w, pattern, false, false,
		NULL, "um.srvname", "um.usename", NULL)

	fmt.Fprint(w, "ORDER BY 1, 2;")

	// res = PSQLexec(buf.data);
	// termPQExpBuffer(w);
	// if (!res)
	// return false;

	// myopt.nullPrint = NULL;
	// myopt.title = _("List of user mappings");
	// myopt.translate_header = true;

	// printQuery(res, &myopt, pset.queryFout, false, pset.logfile);

	// PQclear(res);
	// return true;
	return nil
}
